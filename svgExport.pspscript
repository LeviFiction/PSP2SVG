from JascApp import *
import Tkinter
import tkFileDialog
import xml.etree.cElementTree as xml
import os

genSilent = {'ExecutionMode': App.Constants.ExecutionMode.Silent, 
             'AutoActionMode': App.Constants.AutoActionMode.Match, 
             'Version': ((9,0,0),1),
             }

def ScriptProperties():
    return {
        'Author': u'LeviFiction',
        'Copyright': u'2021',
        'Description': u'Exports entire image to SVG format',
        'Host': u'PaintShop Pro',
        'Host Version': u'9.00'
        }

def Do(Environment):
    Tkinter.Tk().withdraw()
    filename = tkFileDialog.asksaveasfilename(initialdir = user_path('Pictures'),title = "Export SVG",filetypes = (("SVG","*.svg"),))
    print(filename)
    svg_data = makeSVG(Environment)
    SaveSVG(filename, svg_data)

# This function is used to see if materials already exist as resource
def elements_equal(e1, e2):
    """Determine if two elements are the same"""
    if e1.tag != e2.tag: return False
    if e1.text != e2.text: return False
    if e1.tail != e2.tail: return False
    if e1.attrib != e2.attrib: return False
    if len(e1) != len(e2): return False
    return all(elements_equal(c1, c2) for c1, c2 in zip(e1, e2))

def makeSVG(Environment, includeRaster=False, Embed=True):
    """Start process of converting full document to SVG"""
    current_layer_path = None
    rootTree = xml.Element('svg', {'version':"1.1", 
                                   'width':str(App.TargetDocument.Width),
                                   'height':str(App.TargetDocument.Height),
                                   'xmlns': "http://www.w3.org/2000/svg"})
    selectBottomLayer(Environment)
    newLayer = True
    while newLayer:
        result = returnLayerProperties(Environment)
        if result['Path'] == current_layer_path:
            break
        else:
            current_layer_path = result['Path']
        if result['LayerType'] in [0,4,5,6,7,8,9,10,11,12,13,14,15] and includeRaster:
            print("Not a good layer")
        elif result['LayerType'] == 1:
            group = createGroup(validName(result['General']['Name']))
            objs = True
            while objs:
                color = "RGB(0,0,0"
                objs = nextObject(Environment)
                if objs:
                    obj = objs['ListOfObjects'][0]
                    if obj['ObjectType'] == 'Group':
                        #createVectorGroup(group, objs)
                        print("Create Vector Group")
                        create_vector_group(Environment, group, objs)
                    elif obj['ObjectType'] == 'Rectangle':
                        data = obj['RectangleData']
                        if data['Fill']['Color']:
                            color = "RGB"+str(data['Fill']['Color'])
                        addRect(group, data['ObjectName'],
                                       data['Top'],
                                       data['Left'],
                                       data['Width'],
                                       data['Height'],
                                       data['RadiusX'],
                                       data['RadiusY'],
                                       data['Matrix'], color)
                    elif obj['ObjectType'] == 'Ellipse':
                        data = obj['EllipseData']
                        if data['Fill']['Color']:
                            color = "RGB"+str(data['Fill']['Color'])
                        addEllipse(group, data['ObjectName'],
                                          data['CenterX'],
                                          data['CenterY'],
                                          data['RadiusX'],
                                          data['RadiusY'],
                                          data['Matrix'], color)
                    elif obj['ObjectType'] == 'SymmetricShape':
                        convert_to_path(Environment, obj['Path'])
                        current_object = returnVectorProperties(Environment)['ListOfObjects'][0]
                        data = current_object['ObjectData']
                        if data['Fill']['Color']:
                            color = "RGB"+str(data['Fill']['Color'])
                        addPath(group, data['ObjectName'], data['Path'], color)
                    elif obj['ObjectType'] in ['Text', 'TextEx']:
                        convert_to_path(Environment, obj['Path'])
                        current_object = returnVectorProperties(Environment)['ListOfObjects'][0]
                        data = current_object['ObjectData']
                        if data['Fill']['Color']:
                            color = "RGB"+str(data['Fill']['Color'])
                        addPath(group, data['ObjectName'], data['Path'], color)
                    elif obj['ObjectType'] == 'Path':
                        data = obj['ObjectData']
                        if data['Fill']['Color']:
                            color = "RGB"+str(data['Fill']['Color'])
                        addPath(group, data['ObjectName'], data['Path'], color)

            rootTree.insert(len(rootTree), group)
        newLayer = selectNextLayer(Environment)

    return rootTree

def createGroup(id):
    """Create SVG Group usually represents a layer"""
    return xml.Element('g', {'id': id})

def createVectorGroup(group, groupData):
    """PSP returns all elements in a vector group, and sub groups, parse list and return group"""
    # List of groups to sort through
    groups = []
    # Loop over all objects in list
    for current_object in groupData['ListOfObjects']:
        # If object is a group, the next objects will be the children up to the count in Child Count
        if current_object['ObjectType'] == 'Group':
            # Add group to groups list
            groups.append(xml.Element('g', {'id':validName(current_object['GroupName']), 'count':current_object['Child Count']}))
        elif current_object['ObjectType'] == 'Rectangle':
            # Add rectangle to current group
            data = current_object['RectangleData']
            addRect(groups[-1], validName(data['ObjectName']),
                                data['Top'],
                                data['Left'],
                                data['Width'],
                                data['Height'],
                                data['RadiusX'],
                                data['RadiusY'],
                                data['Matrix'])
        elif current_object['ObjectType'] == 'Ellipse':
            # Add ellipse to current group
            data = current_object['EllipseData']
            addEllipse(groups[-1], validName(data['ObjectName']),
                                   data['CenterX'],
                                   data['CenterY'],
                                   data['RadiusX'],
                                   data['RadiusY'],
                                   data['Matrix'])
        elif current_object['Path']:
            # Add path to current group
            data = current_object['ObjectData']
            addPath(groups[-1], data['ObjectName'], data['Path'])

        if groups[-1].attrib['count'] == len(groups[-1].getchildren()):
            # If we've added all children that exist in group
            # And there is more than one group
            # Add last group as child to previous group
            if len(groups) > 1:
                g = groups.pop() # remove last group
                g.attrib.pop('count') # remove count attribute from group
                groups[-1].insert(len(groups[-1].getchildren()), g) # Add group to previous group 
    groups[-1].attrib.pop('count') # remove count attribute from top level group
    group.insert(len(group.getchildren()), groups[-1]) # Add final group to layer group

def create_vector_group(Env, group, groupData):
    """PSP returns all elements in a vector group, and sub groups, parse list and return group"""
    # First go through all objects in group to convert unsupported objects
    # reset is used to determine if we need to reselect the vector group
    reset = False
    current_path = groupData['ListOfObjects'][0]['Path']
    for current_object in groupData['ListOfObjects']:
        if current_object['ObjectType'] in ['SymmetricShape', 'Text', 'TextEx']:
            reset = True
            convert_to_path(Env, current_object['Path'])
    if reset:
        select_vector_absolute(Env, current_path)
        groupData = returnVectorProperties(Env)

    # List of groups to sort through
    groups = []
    # Loop over all objects in list
    for current_object in groupData['ListOfObjects']:
        # If object is a group, the next objects will be the children up to the count in Child Count
        if current_object['ObjectType'] == 'Group':
            # Add group to groups list
            groups.append(xml.Element('g', {'id':validName(current_object['GroupName']), 'count':current_object['Child Count']}))
        elif current_object['ObjectType'] == 'Rectangle':
            # Add rectangle to current group
            data = current_object['RectangleData']
            addRect(groups[-1], validName(data['ObjectName']),
                                data['Top'],
                                data['Left'],
                                data['Width'],
                                data['Height'],
                                data['RadiusX'],
                                data['RadiusY'],
                                data['Matrix'])
        elif current_object['ObjectType'] == 'Ellipse':
            # Add ellipse to current group
            data = current_object['EllipseData']
            addEllipse(groups[-1], validName(data['ObjectName']),
                                   data['CenterX'],
                                   data['CenterY'],
                                   data['RadiusX'],
                                   data['RadiusY'],
                                   data['Matrix'])
        elif current_object['Path']:
            # Add path to current group
            data = current_object['ObjectData']
            addPath(groups[-1], data['ObjectName'], data['Path'])

        if groups[-1].attrib['count'] == len(groups[-1].getchildren()):
            # If we've added all children that exist in group
            # And there is more than one group
            # Add last group as child to previous group
            if len(groups) > 1:
                g = groups.pop() # remove last group
                g.attrib.pop('count') # remove count attribute from group
                groups[-1].insert(len(groups[-1].getchildren()), g) # Add group to previous group 
    groups[-1].attrib.pop('count') # remove count attribute from top level group
    group.insert(len(group.getchildren()), groups[-1]) # Add final group to layer group

# TODO: Add text support
def addType(data):
    """I think this is supposed to be text"""
    pass

def validName(Name):
    """Format current name to match SVG specs"""
    return Name.replace(" ", "_")

def SaveSVG(filename, rootTree):
    """Save SVG data to filename"""
    top = "<?xml version='1.0' standalone='no'?>"
    doctype = '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'
    with open(filename, 'w') as f:
        f.write(top)
        f.write(doctype)
        f.write(xml.tostring(rootTree))

def addEllipse(root, id, x,y,rx,ry,matrix=None, color="RGB(0,0,0"):
    """Convert Ellipse data to SVG and add to root"""
    print("Entered Ellipse")
    print(matrix)
    if matrix:
        xml.SubElement(root, 'ellipse', {'id': id, 'cx': str(x), 'cy': str(y), 'rx':str(rx), 'ry':str(ry), 'transform':pspMatrixToSVG(matrix), 'fill':color })        
    else:
        xml.SubElement(root, 'ellipse', {'id': id, 'cx': str(x), 'cy': str(y), 'rx':str(rx), 'ry':str(ry), 'fill':color})

def addRect(root, id, top, left, width, height, rx, ry, matrix = None, color="RGB(0,0,0"):
    """Convert Rectangle data to SVG and add to root"""
    print("Entered Rectangle")
    print(matrix)
    if matrix:
        xml.SubElement(root, 'rect', {'id': id, 'x': str(left), 'y': str(top), 'width':str(width), 'height':str(height), 'rx':str(rx), 'ry':str(ry), 'transform':pspMatrixToSVG(matrix), 'fill':color })        
    else:
        xml.SubElement(root, 'rect', {'id': id, 'x': str(left), 'y': str(top), 'width':str(width), 'height':str(height), 'rx':str(rx), 'ry':str(ry), 'fill':color})

def addPath(root, id, path, color="RGB(0,0,0"):
    """Convert Path data to SVG and add to root"""
    cmd = ['M', 'L', 'C', 'Z']
    pathstr = ""
    for node in path:
        pathstr += cmd[node[0]] + " "
        for i,d in enumerate(node):
            if i == 0:
                continue
            pathstr += ",".join(list(map(str, d))) + " " 
    xml.SubElement(root, 'path', {'id':id, 'd':pathstr, 'fill':color})

def user_path(*paths):
    return os.path.join(os.environ['USERPROFILE'], *paths)

def embedImage(Environment, root, filename):
    """Open file, save as png and embed into xml"""
    svgpng = user_path('AppData', 'Local', 'Temp','svgpng.png')
    openImage(Environment, filename)
            
    Doc = App.Documents[-1]
    w = Doc.Width
    h = Doc.Height

    # FileSaveCopyAs
    App.Do( Environment, 'FileSaveCopyAs', {
            'Encoding': {'PNG': {'Interlaced': False, 'OptimizedPalette': True, 'AlphaChannel': True }}, 
            'FileName': svgpng, 
            'FileFormat': App.Constants.FileFormat.PNG, 
            'FormatDesc': u'PNG Portable Network Graphics', 
            'WorkingMode': 0, 
            'GeneralSettings': genSilent, 
            'DefaultProperties': []
            }, Doc)
    
    App.Do( Environment, 'FileClose', {}, Doc)
    
    with open(user_path("AppData","Local","Temp","svgpng.png"), 'rb') as f:
        data = f.read()
        xml.SubElement(root, 'image', {'width':str(w), 'height':str(h), 'href':'data:image/png;base64,' + data.encode("base64")})

def openImage(Environment, filename =""):
    """Open specific image"""
    inter = App.Constants.ExecutionMode.Interactive
    mode = genSilent.copy()
    if filename:
        mode['ExecutionMode'] = inter
    # FileOpen
    App.Do( Environment, 'FileOpen', {
            'FileList':[filename], 
            'Folder': u'C:\\Users\\matthewjohnson\\Pictures', 
            'FileFormat': App.Constants.FileFormat.Unknown, 
            'ShowPreview': True, 
            'EnableBrowser': True, 
            'FavFileList': [], 
            'FileOpenScript': u'', 
            'EnablePreprocessing': False, 
            'GeneralSettings': mode
            })

def pspMatrixToSVG(matrix):
    """Conver PSP matrix to SVG format"""
    print("Entered Matrix")
    print(matrix)
    if matrix:
        return "matrix"+str((matrix[0],matrix[3],matrix[1],matrix[4],matrix[2],matrix[5]))
    return None

# TODO: Add pre-formatting for unsupported vector types
def convert_to_path(Env, vector_object_path):
    """Perform Convert to path on vector object"""
    selectBottomLayer(Env)
    select_vector(Env, vector_object_path)
    # ConvertToPath
    App.Do( Env, 'ConvertToPath', {})

def selectBottomLayer(Environment):
    """Selects bottom most layer in layer's palette"""
    App.Do(Environment, 'SelectLayer', {'Path': (9999, -9999, [], False)})

def selectNextLayer(Environment):
    """Selects next full layer"""
    return App.Do(Environment, 'SelectNextLayer', {})

def select_vector(Environment, path):
    """Selects vector identified by path"""
    return App.Do(Environment, 'VectorSelectionUpdate', 
                               {'Path':path, 
                               'Type':App.Constants.ObjectSelection.Select})

def select_vector_absolute(Environment, path):
    """Selects vector identified by path"""
    selectBottomLayer(Environment)
    return App.Do(Environment, 'VectorSelectionUpdate', 
                               {'Path':path, 
                               'Type':App.Constants.ObjectSelection.Select})

def nextObject(Environment):
    """If layer contains another vector object return object list"""
    if App.Do(Environment, 'GetNextObject')['HaveObject']:
        return returnVectorProperties(Environment)
    else:
        return None

def returnLayerProperties(Environment):
    """Return layer properties"""
    result = {}
    result = App.Do(Environment, 'ReturnLayerProperties')
    return result

def returnVectorProperties(Environment):
    """Return vector object properties as list of objects"""
    return App.Do(Environment, 'ReturnVectorObjectProperties', {})
